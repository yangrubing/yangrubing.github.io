<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="月光下的影子" type="application/atom+xml">






<meta name="description" content="Only the stronger survive in the world.">
<meta property="og:type" content="website">
<meta property="og:title" content="月光下的影子">
<meta property="og:url" content="https://yangrubing.github.io/page/2/index.html">
<meta property="og:site_name" content="月光下的影子">
<meta property="og:description" content="Only the stronger survive in the world.">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="月光下的影子">
<meta name="twitter:description" content="Only the stronger survive in the world.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://yangrubing.github.io/page/2/">





  <title>月光下的影子</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?825171e0a864b9dffeb590351c2abc71";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">月光下的影子</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Only the stronger survives in this world.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yangrubing.github.io/2017/08/24/装饰者模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Robin Yang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar/obito.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="月光下的影子">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/24/装饰者模式/" itemprop="url">装饰者模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-24T10:45:09+00:00">
                2017-08-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p> The Decorator pattern is a more flexible alternative to subclassing. The Decorator class implements the same interface as the target and uses aggregation to “decorate” calls to thetarget. Using the Decorator pattern it is possible to change the behavior of the class during runtime.</p>
</blockquote>
<p>装饰者模式（<code>decorator</code>）有时又被称为包装者模式（<code>Wrapper</code>）。该模式可以动态的、透明的给对象赋予某些额外的功能。<br>我们常用的<code>BufferedInputStream</code>就是<code>InputStream</code>的一个装饰者，或者称之为包装类(<code>Wrapper</code>)，通过这样我们可以给我们的输入流提供了额外的缓存的功能。<br>装饰者<code>Decorator</code>和目标的类<code>Target</code>实现同一个接口，使用装饰者模式可以在运行时改变类的行为。</p>
<h3 id="装饰者模式的意图"><a href="#装饰者模式的意图" class="headerlink" title="装饰者模式的意图"></a>装饰者模式的意图</h3><blockquote>
<p>Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality. </p>
</blockquote>
<p>上面这句话的意思是说装饰者模式的意图是给一个对象动态的添加一些功能。相较于子类化来说，装饰者模式更加的灵活可变。</p>
<h3 id="装饰者模式适用的场景"><a href="#装饰者模式适用的场景" class="headerlink" title="装饰者模式适用的场景"></a>装饰者模式适用的场景</h3><ul>
<li>用于给对象动态的、透明的添加某些功能。同时又不会影响到其他的对象。</li>
<li>当使用继承扩展一个对象是不合适的时候（继承最好是”IS-A”)的关系。</li>
<li>有的类是不能继承的，但是你又希望在使用的时候增强它的功能。</li>
</ul>
<h3 id="具体实例"><a href="#具体实例" class="headerlink" title="具体实例"></a>具体实例</h3><p>这个装饰者模式的例子共有4个关键的类。<code>Troll</code>巨魔接口， <code>SimpleTroll</code> 普通巨魔， <code>TrollDecorator</code> 巨魔装饰者以及 <code>ClubbedTroll</code> 棍棒巨魔。类之间的继承关系如图所示：<br><img src="/images/2017-08-24-11-29-48.jpg" alt="装饰者模式类图"><br>从图中可以看到，<code>SimpleTroll</code>和装饰者<code>TrollDecorator</code>都实现了 <code>Troll</code> 接口。<code>TrollDecorator</code> 包含了一个 <code>Troll</code> 的引用，并对其中的方法使用该引用进行执行。<code>ClubbedTroll</code> 继承了 <code>TrollDecorator</code> ，它也是个装饰器，并对其中的一些方法进行了增强。具体代码如下：<br><code>Troll</code> 接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Troll</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">attack</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getAttackPower</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">fleeBattle</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>装饰者<code>TrollDecorator</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TrollDecorator是一个装饰者，持有了一个被装饰者的引用</span></span><br><span class="line"><span class="comment"> * 它会拦截对被装饰者的调用，并将调用委托为被装饰者执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrollDecorator</span> <span class="keyword">implements</span> <span class="title">Troll</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Troll decorated;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TrollDecorator</span><span class="params">(Troll decorated)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.decorated = decorated;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    decorated.attack();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAttackPower</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> decorated.getAttackPower();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fleeBattle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    decorated.fleeBattle();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>目标类也就是被装饰者<code>SimpleTroll</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*目标类也就是被装饰者SimpleTroll</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleTroll</span> <span class="keyword">implements</span> <span class="title">Troll</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(SimpleTroll.class);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"The troll tries to grab you!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAttackPower</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fleeBattle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"The troll shrieks in horror and runs away!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 装饰者，继承自TrollDecorator</span></span><br><span class="line"><span class="comment"> * 并对attack和getAttackPower方法进行了扩展</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClubbedTroll</span> <span class="keyword">extends</span> <span class="title">TrollDecorator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(ClubbedTroll.class);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ClubbedTroll</span><span class="params">(Troll decorated)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(decorated);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.attack();</span><br><span class="line">    LOGGER.info(<span class="string">"The troll swings at you with a club!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAttackPower</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getAttackPower() + <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(App.class);</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// simple troll</span></span><br><span class="line">    LOGGER.info(<span class="string">"A simple looking troll approaches."</span>);</span><br><span class="line">    Troll troll = <span class="keyword">new</span> SimpleTroll();</span><br><span class="line">    troll.attack();</span><br><span class="line">    troll.fleeBattle();</span><br><span class="line">    LOGGER.info(<span class="string">"Simple troll power &#123;&#125;.\n"</span>, troll.getAttackPower());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// change the behavior of the simple troll by adding a decorator</span></span><br><span class="line">    LOGGER.info(<span class="string">"A troll with huge club surprises you."</span>);</span><br><span class="line">    Troll clubbed = <span class="keyword">new</span> ClubbedTroll(troll);</span><br><span class="line">    clubbed.attack();</span><br><span class="line">    clubbed.fleeBattle();</span><br><span class="line">    LOGGER.info(<span class="string">"Clubbed troll power &#123;&#125;.\n"</span>, clubbed.getAttackPower());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span>:<span class="number">03</span>:<span class="number">44.314</span> [main] INFO com.iluwatar.decorator.App - A simple looking troll approaches.</span><br><span class="line"><span class="number">11</span>:<span class="number">03</span>:<span class="number">44.317</span> [main] INFO com.iluwatar.decorator.SimpleTroll - The troll tries to grab you!</span><br><span class="line"><span class="number">11</span>:<span class="number">03</span>:<span class="number">44.317</span> [main] INFO com.iluwatar.decorator.SimpleTroll - The troll shrieks in horror and runs away!</span><br><span class="line"><span class="number">11</span>:<span class="number">03</span>:<span class="number">44.317</span> [main] INFO com.iluwatar.decorator.App - Simple troll power <span class="number">10</span>.</span><br><span class="line"></span><br><span class="line"><span class="number">11</span>:<span class="number">03</span>:<span class="number">44.319</span> [main] INFO com.iluwatar.decorator.App - A troll with huge club surprises you.</span><br><span class="line"><span class="number">11</span>:<span class="number">03</span>:<span class="number">44.320</span> [main] INFO com.iluwatar.decorator.SimpleTroll - The troll tries to grab you!</span><br><span class="line"><span class="number">11</span>:<span class="number">03</span>:<span class="number">44.320</span> [main] INFO com.iluwatar.decorator.ClubbedTroll - The troll swings at you with a club!</span><br><span class="line"><span class="number">11</span>:<span class="number">03</span>:<span class="number">44.320</span> [main] INFO com.iluwatar.decorator.SimpleTroll - The troll shrieks in horror and runs away!</span><br><span class="line"><span class="number">11</span>:<span class="number">03</span>:<span class="number">44.320</span> [main] INFO com.iluwatar.decorator.App - Clubbed troll power <span class="number">20</span>.</span><br></pre></td></tr></table></figure></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>装饰者模式可以透明的给一个对象增加功能，并不改变对象的使用方法，在现实中使用的也是比较多的。如我们经常用的 <code>BufferedInputStream</code> 就是一个装饰者，它给 <code>InputStream</code> 类增加了缓存的功能。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">"path"</span>);</span><br><span class="line">BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(is);</span><br></pre></td></tr></table></figure></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="http://java-design-patterns.com/patterns/decorator/" target="_blank" rel="noopener">Decorator</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yangrubing.github.io/2017/08/23/观察者模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Robin Yang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar/obito.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="月光下的影子">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/23/观察者模式/" itemprop="url">观察者模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-23T16:50:00+00:00">
                2017-08-23
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>首先来看看最简单的观察者模式，使用<code>java.util</code>包实现的观察者模式。使用另个类，一个是<code>java.util.Observer</code>接口以及<code>java.util.Observable</code>来实现。（除了直接使用java提供的现成的观察者类以外，我们也可以自己实现观察者模式）直接上代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 观察者A</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObserverA</span> <span class="keyword">implements</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">    	<span class="comment">//arg为接收到的消息，收到消息直接print</span></span><br><span class="line">		System.out.println(<span class="string">"A received:"</span> + arg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 观察者B</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObserverB</span> <span class="keyword">implements</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"B received:"</span> + arg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主题类，也就是被观察的类</span></span><br><span class="line"><span class="comment"> * 直接继承自Observable接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> <span class="keyword">extends</span> <span class="title">Observable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">    	<span class="comment">//添加观察者</span></span><br><span class="line">		addObserver(<span class="keyword">new</span> ObserverA());</span><br><span class="line">		addObserver(<span class="keyword">new</span> ObserverB());</span><br><span class="line">        <span class="comment">//设置状态已经改变		</span></span><br><span class="line">		setChanged();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		Subject subject = <span class="keyword">new</span> Subject();</span><br><span class="line">		subject.notifyObservers(<span class="string">"hello"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B received: hello</span><br><span class="line">A received: hello</span><br></pre></td></tr></table></figure></p>
<p>上面的代码很简单，<code>Subject</code>类实现了<code>Observable</code>接口，表明了它是一个主题（被观察者）。然后，它本身持有了两个观察者的引用 <code>ObserverA</code> 和 <code>ObserverB</code> 。当<code>Subject</code> 类的状态改变时，观察者将会调用<code>update()</code>方法来进行相应的操作。<br>注意，<code>Subject</code> 类在通知观察者的时候，只知道这些是观察者（实现了 <code>Observer</code> )接口，但是并不知道是哪个观察者。同时，它也不知道观察者的具体实现，这样就实现了主题和观察者之间的<strong>松耦合</strong>。下面详细介绍观察者模式的使用场景以及实现。</p>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><h3 id="观察者模式的设计意图"><a href="#观察者模式的设计意图" class="headerlink" title="观察者模式的设计意图"></a>观察者模式的设计意图</h3><blockquote>
<p>定义对象之间的一对多依赖关系，这样当一个对象改变状态时，所有的依赖项都会自动得到通知和更新。</p>
</blockquote>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>在以下情况，可以考虑使用观察者模式：</p>
<ul>
<li>当一个问题的抽象后有两个主要操作A和B，一个依赖于另一个。将这些操作封装在单独的对象中，可以可以独立地进行更改和重用。</li>
<li>当对一个对象的状态改变时，需要更改其他对象，但是不知道需要更改哪些对象。</li>
<li>希望实现两个对象之间的松耦合。</li>
</ul>
<p>在上面的描述中，最典型的使用场景就是<strong>一个对象的改变，需要将其他对象也进行相应的操作</strong>（主题通知观察者）。</p>
<h3 id="具体实例"><a href="#具体实例" class="headerlink" title="具体实例"></a>具体实例</h3><p>天气 <code>Weather</code>的改变将会导致其他物种的改变，半兽人 <code>Orcs</code>和霍比特人<code>Hobbits</code>对于天气的改变将会做出不同的反应。在这个实例中，天气就是一个主题，也就是被观察者；半兽人和霍比特人就是观察者，他们会随着天气的变化来相应的变化。<br>类之间的关系图如下图所示：<br><img src="/images/2017-08-23-17-31-44.jpg" alt="观察者之间的类图"><br><code>WeatherObserver</code>接口定义了一个<code>update()</code>方法。两个观察者<code>Hobbits</code>和<code>Orcs</code>实现了该接口。主题类<code>Weather</code>中有增加、删除、通知观察者的方法，当<code>timePasses</code>方法执行时，将会通知已经注册的观察者；<code>WeatherType</code>是一个天气的枚举类。具体实现代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 观察者接口</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WeatherObserver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(WeatherType currentWeather)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>两个观察者Hobbits和Orcs。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Hobbits</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hobbits</span> <span class="keyword">implements</span> <span class="title">WeatherObserver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Hobbits.class);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(WeatherType currentWeather)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (currentWeather) &#123;</span><br><span class="line">      <span class="keyword">case</span> COLD:</span><br><span class="line">        LOGGER.info(<span class="string">"The hobbits are shivering in the cold weather."</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> RAINY:</span><br><span class="line">        LOGGER.info(<span class="string">"The hobbits look for cover from the rain."</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> SUNNY:</span><br><span class="line">        LOGGER.info(<span class="string">"The happy hobbits bade in the warm sun."</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> WINDY:</span><br><span class="line">        LOGGER.info(<span class="string">"The hobbits hold their hats tightly in the windy weather."</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Orcs</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Orcs</span> <span class="keyword">implements</span> <span class="title">WeatherObserver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Orcs.class);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(WeatherType currentWeather)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (currentWeather) &#123;</span><br><span class="line">      <span class="keyword">case</span> COLD:</span><br><span class="line">        LOGGER.info(<span class="string">"The orcs are freezing cold."</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> RAINY:</span><br><span class="line">        LOGGER.info(<span class="string">"The orcs are dripping wet."</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> SUNNY:</span><br><span class="line">        LOGGER.info(<span class="string">"The sun hurts the orcs' eyes."</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> WINDY:</span><br><span class="line">        LOGGER.info(<span class="string">"The orc smell almost vanishes in the wind."</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面是主题类<code>Weather</code>的定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 天气的枚举</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> WeatherType &#123;</span><br><span class="line"></span><br><span class="line">  SUNNY, RAINY, WINDY, COLD;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name().toLowerCase();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Weather can be observed by implementing &#123;<span class="doctag">@link</span> WeatherObserver&#125; interface and registering as</span></span><br><span class="line"><span class="comment"> * listener.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Weather</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Weather.class);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> WeatherType currentWeather;</span><br><span class="line">  <span class="keyword">private</span> List&lt;WeatherObserver&gt; observers;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Weather</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    observers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    currentWeather = WeatherType.SUNNY;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(WeatherObserver obs)</span> </span>&#123;</span><br><span class="line">    observers.add(obs);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(WeatherObserver obs)</span> </span>&#123;</span><br><span class="line">    observers.remove(obs);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Makes time pass for weather</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">timePasses</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    WeatherType[] enumValues = WeatherType.values();</span><br><span class="line">    currentWeather = enumValues[(currentWeather.ordinal() + <span class="number">1</span>) % enumValues.length];</span><br><span class="line">    LOGGER.info(<span class="string">"The weather changed to &#123;&#125;."</span>, currentWeather);</span><br><span class="line">    notifyObservers();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (WeatherObserver obs : observers) &#123;</span><br><span class="line">      obs.update(currentWeather);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试类的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(App.class);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Program entry point</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> args command line args</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1. 定义了一个主题</span></span><br><span class="line">    Weather weather = <span class="keyword">new</span> Weather();</span><br><span class="line">    <span class="comment">//2. 添加两个观察者    </span></span><br><span class="line">    weather.addObserver(<span class="keyword">new</span> Orcs());</span><br><span class="line">    weather.addObserver(<span class="keyword">new</span> Hobbits());</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//3. 当主题改变时看观察者的变化</span></span><br><span class="line">    weather.timePasses();</span><br><span class="line">    weather.timePasses();</span><br><span class="line">    weather.timePasses();</span><br><span class="line">    weather.timePasses();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">17</span>:<span class="number">27</span>:<span class="number">44.181</span> [main] INFO com.iluwatar.observer.Weather - The weather changed to rainy.</span><br><span class="line"><span class="number">17</span>:<span class="number">27</span>:<span class="number">44.185</span> [main] INFO com.iluwatar.observer.Orcs - The orcs are dripping wet.</span><br><span class="line"><span class="number">17</span>:<span class="number">27</span>:<span class="number">44.186</span> [main] INFO com.iluwatar.observer.Hobbits - The hobbits look <span class="keyword">for</span> cover from the rain.</span><br><span class="line"><span class="number">17</span>:<span class="number">27</span>:<span class="number">44.186</span> [main] INFO com.iluwatar.observer.Weather - The weather changed to windy.</span><br><span class="line"><span class="number">17</span>:<span class="number">27</span>:<span class="number">44.186</span> [main] INFO com.iluwatar.observer.Orcs - The orc smell almost vanishes in the wind.</span><br><span class="line"><span class="number">17</span>:<span class="number">27</span>:<span class="number">44.186</span> [main] INFO com.iluwatar.observer.Hobbits - The hobbits hold their hats tightly in the windy weather.</span><br><span class="line"><span class="number">17</span>:<span class="number">27</span>:<span class="number">44.186</span> [main] INFO com.iluwatar.observer.Weather - The weather changed to cold.</span><br><span class="line"><span class="number">17</span>:<span class="number">27</span>:<span class="number">44.186</span> [main] INFO com.iluwatar.observer.Orcs - The orcs are freezing cold.</span><br><span class="line"><span class="number">17</span>:<span class="number">27</span>:<span class="number">44.186</span> [main] INFO com.iluwatar.observer.Hobbits - The hobbits are shivering in the cold weather.</span><br><span class="line"><span class="number">17</span>:<span class="number">27</span>:<span class="number">44.186</span> [main] INFO com.iluwatar.observer.Weather - The weather changed to sunny.</span><br><span class="line"><span class="number">17</span>:<span class="number">27</span>:<span class="number">44.186</span> [main] INFO com.iluwatar.observer.Orcs - The sun hurts the orcs<span class="string">' eyes.</span></span><br><span class="line"><span class="string">17:27:44.186 [main] INFO com.iluwatar.observer.Hobbits - The happy hobbits bade in the warm sun.</span></span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yangrubing.github.io/2017/08/22/JVM垃圾收集器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Robin Yang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar/obito.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="月光下的影子">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/22/JVM垃圾收集器/" itemprop="url">JVM垃圾收集器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-22T17:56:00+00:00">
                2017-08-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>垃圾收集器</strong>就是将垃圾回收算法进行了具体的实现，Java虚拟机规范中对于垃圾收集器并没有做任何规定，因此不同的厂商可以自由的实现自己的垃圾收集器。<br>下图展示的为HotSpot虚拟机的垃圾收集器，如果两个收集器之间有连线，则表示两者可以配合使用，反之，则不能配合使用。<br><img src="/images/1503395957.png" alt="HotSpot虚拟机的垃圾收集器"><br>从图中可以看出，Serial、ParNew、Parallel Scavenge三个收集器负责收集<strong>新生代</strong>；CMS、Serial Old、Parallel Old负责<strong>老年代的垃圾收集</strong>；<strong>G1</strong>收集器既可以收集老年代又可以收集新生代。</p>
<h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>该收集器采用“单线程”、串行的方式进行垃圾收集。它这个”单线程”不止是说只是用一条线程来进行工作，最重要的是它进行垃圾收集时，它会暂停掉其他所有的工作线程，直到收集工作结束。<strong>新生代</strong>采用复制算法，<strong>老年代</strong>采用标记整理算法。<br>Serial收集器的优点是<strong>简单和高效</strong>，但是其在收集时会”Stop The World!”。<br>Serial收集器工作示意图：<br><img src="/images/1503397030.png" alt="Serial收集器工作示意图"></p>
<h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>ParNew收集器其实就是Serial收集器的多线程版本，除了多线程以外，该收集器与串行收集器相比并没有太多的创新之处，但是它是Server模式下首选的<strong>新生代收集器</strong>。从图中可以看出，目前除了Serial收集器以外，只有ParNew可以和CMS收集器一起工作，CMS收集器负责<strong>老年代</strong>的垃圾收集。ParNew收集器也是使用<code>-XX：+UseConcMarkSweepGC</code>选项后的默认新生代收集器，也可以使用<code>-XX：+UseParNewGC</code> 选项来强制指定它。<br>ParNew收集器运行示意图：<br><img src="/images/1503459184.png" alt="ParNew收集器运行示意图"><br>垃圾收集中，并行与并发的含义：</p>
<ul>
<li>并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</li>
<li>并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行于另一个CPU上。</li>
</ul>
<h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p>该收集器关注的点与CMS不同。CMS等收集器的关注点是尽可能地缩短垃圾收集时<strong>用户线程的停顿时间</strong>；Parallel Scavenge收集器关注的是<strong>吞吐量的可控</strong>。<br>所谓<strong>吞吐量</strong>就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间），虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。<br>停顿时间短更适合与用户交互的程序（CMS），而<strong>吞吐量</strong>高，则可以更好的利用CPU资源，适合于在后台运算，而不需要太多的交互的任务。（Parallel Scavenge）<br>在使用时Parallel Scavenge有几个参数可以设置：</p>
<ul>
<li><code>-XX：MaxGCPauseMillis</code>。用来设置垃圾回收停顿间隔，单位是毫秒。</li>
<li><code>-XX：GCTimeRatio</code>。直接设置吞吐量，是一个大于0小于100的整数，吞吐量的概念在上面已经介绍过了。</li>
<li><code>-XX：+UseAdaptiveSizePolicy</code>。使用自适应的调节策略，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种调节方式称为GC自适应的调节策略（GC Ergonomics）。该策略也是Parallel Scavenge收集器与ParNew收集器的一个重要区别。</li>
</ul>
<p>上面三个收集器都是<strong>新生代</strong>的收集器，下面这将会介绍<strong>老年代</strong>的垃圾收集器。</p>
<h3 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3><p>穿行收集器的老年代版本，使用单线程进行垃圾收集了。在进行垃圾收集时也需要暂停所有用户线程。<br>Serial Old收集器的运行示意图如图所示：<br><img src="/images/1503468662.png" alt="Serial Old老年代的运行示意图"></p>
<h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><p>该收集器可以与Parallel Scavenge收集器一起工作，<strong>在注重“吞吐量优先”以及CPU资源敏感的场合，优先考虑使用Parallel Scavenge加Parallel Old收集器</strong>。<br>Parallel Old收集器的工作流如图所示：<br><img src="/images/1503472199.png" alt="Parallel Old收集器的工作流程图"></p>
<h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>CMS（Concurrent Mark Sweep)收集器的目标是缩短用户线程的停顿时间，在注重用户交互的服务器端，可以采用该收集器来进行老年代的收集。<br>该收集器是基于“标记-清除”算法来实现的，总共分为四个步骤：</p>
<ul>
<li>初始标记（CMS initial mark）</li>
<li>并发标记（CMS concurrent mark）</li>
<li>重新标记（CMS remark）</li>
<li>并发清除（CMS concurrent sweep）<br>初始标记、重新标记两个步骤仍然需要暂停所有用户线程。初始标记仅仅标记GC Roots能够直接关联的对象，速度很快；并发标记阶段是进行GC RootsTracing的过程；重新标记是标记那些由于用户程序继续运行而产生变化的那部分对象的标记记录。<br>由于整个过程中耗时最长的<strong>并发标记</strong>和<strong>并发清除</strong>过程收集器线程都可以与用户线程一起工作，<strong>所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的</strong>。<br><img src="/images/1503472617.png" alt="CMS收集器运行示意图"><br>CMS收集器的缺点：</li>
<li>CMS收集器对CPU资源非常敏感，由于与用户线程并发运行，因此也降低了系统的吞吐量。</li>
<li>CMS收集器无法收集浮动垃圾（Floating Garbage），浮动垃圾指的就是由于CMS并发清理阶段用户线程还在运行着，这部分产生的来及只能等到下次GC在进行收集。</li>
<li>由于使用的是“标记-清除”算法，在进行清除后可能会产生的大量的内存碎片，从而导致无法进行大对象的分配。</li>
</ul>
<h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>G1收集器的特点如下：</p>
<ul>
<li>并行与并发。G1能充分利用多CPU、 多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿的时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。</li>
<li>分代收集。与其他收集器一样，分代概念在G1中依然得以保留。 虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、 熬过多次GC的旧对象以获取更好的收集效果。</li>
<li>空间整合。与CMS的“标记—清除”算法不同，G1从整体来看是基于“标记—整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。 这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。</li>
<li>可预测的停顿：这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。<br>G1收集器主要包括初始标记（Initial Marking）、并发标记（Concurrent Marking）、最终标记（Final Marking）、筛选回收（Live Data Counting and Evacuation）。<br>G1收集器的工作流程图：<br><img src="/images/1503473301.png" alt="G1收集器的工作流程图"></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文主要介绍了JVM中的几种垃圾收集器的工作方式和原理，分别对于老年代和新生代进行收集。其中，新生代的垃圾收集器包括Serial 、ParNew 、Parallel Scavenge三种，老年代的垃圾收集器主要有Serial Old、Parallel Old以及CMS收集器。CMS收集器更注重的是降低用户线程的停顿时间，而Parallel Scavenge收集器更注重的是吞吐量（用户线程的运行时间/运行总时间）。最后，对G1收集器进行了介绍，描述了该收集器的一些特点。以后会对这些垃圾收集器进行实验分析，敬请期待！</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://book.douban.com/subject/6522893/" target="_blank" rel="noopener">深入理解java虚拟机</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-JVMGarbageCollection/" target="_blank" rel="noopener">JVM 垃圾回收器工作原理及使用实例介绍</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yangrubing.github.io/2017/08/22/JVM的垃圾回收机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Robin Yang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar/obito.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="月光下的影子">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/22/JVM的垃圾回收机制/" itemprop="url">JVM的垃圾回收机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-22T15:39:51+00:00">
                2017-08-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="JVM垃圾回收算法概述"><a href="#JVM垃圾回收算法概述" class="headerlink" title="JVM垃圾回收算法概述"></a>JVM垃圾回收算法概述</h2><p>Java 语言的一大特点就是可以进行自动垃圾回收处理，而无需开发人员过于关注系统资源，例如内存资源的释放情况。自动垃圾收集虽然大大减轻了开发人员的工作量，但是也增加了软件系统的负担。<br>Java在进行垃圾回收之前需要考虑两个问题，即：</p>
<ol>
<li>哪些内存需要回收？</li>
<li>如何回收？<br>其中，第一个问题描述的是如何判断对象已经不需要了，死了，可以回收了。第二个问题则解决了采用哪种垃圾回收算法来回收。下面详细的介绍上述3个问题的解决方法。<h2 id="如何判断对象可以进行回收？"><a href="#如何判断对象可以进行回收？" class="headerlink" title="如何判断对象可以进行回收？"></a>如何判断对象可以进行回收？</h2>判断对象”已死”通常有<strong>引用计数法</strong>和<strong>可达性分析算法</strong>两种方法。<h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3>引用计数器的实现很简单，对于一个对象 <code>A</code>，只要有任何一个对象引用了 <code>A</code>，则 <code>A</code> 的引用计数器就加 1，当引用失效时，引用计数器就减 1。只要对象 <code>A</code> 的引用计数器的值为 0，则对象 <code>A</code> 就不可能再被使用。<br>可以看出，引用计数法很简单，但是存在一种“循环引用”的问题。例如：有对象 <code>A</code> 和对象 <code>B</code>，对象 <code>A</code> 中含有对象 <code>B</code> 的引用，对象 <code>B</code> 中含有对象 <code>A</code> 的引用。此时，对象 <code>A</code> 和对象 <code>B</code> 的引用计数器都不为 0。但是在系统中却不存在任何第 3 个对象引用他们。也就是说，<code>A</code> 和 <code>B</code> 是应该被回收的垃圾对象，但由于垃圾对象间相互引用，从而使垃圾回收器无法识别，引起<strong>内存泄漏</strong>。<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3>在主流的商用程序语言（Java、 C#，甚至包括前面提到的古老的Lisp）的主流实现中，都是称通过<strong>可达性分析</strong>（Reachability Analysis）来判定对象是否存活的。 这个算法的基本思路就是<strong>通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。</strong><br>可作为GC Roots的对象有：<ul>
<li>虚拟机栈（栈中的本地变量表）中引用的对象。</li>
<li>方法区中类静态属性引用的对象。</li>
<li>方法区中常量引用的对象<h3 id="对方法区-永久代-的回收"><a href="#对方法区-永久代-的回收" class="headerlink" title="对方法区(永久代)的回收"></a>对方法区(永久代)的回收</h3>永久代的垃圾收集主要回收两部分内容：<strong>废弃常量</strong>和<strong>无用的类</strong>。 对于常量回收，只要这个常量没有被任何引用，那么就可以进行垃圾回收。要判断一个类是否是无用的类的条件则要苛刻的多，满足以下条件：</li>
<li>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。</li>
<li>加载该类的<code>ClassLoader</code>已经被回收。</li>
<li>该类对应的<code>java.lang.Class</code>对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3>该算法分为两个阶段，即<strong>标记</strong>和<strong>清除</strong>。通过可达性分析算法，<strong>标记</strong>的阶段就是找出可以回收的对象。<strong>清除</strong>就是将这些区域重新可以使用。<br>该算法有两个不足：</li>
<li>效率问题。标记和清除的效率都不高。</li>
<li>空间问题。进行<strong>标记-清除算法</strong>后，将会产生不连续的内存碎片，可能导致无法分配大对象而又进行垃圾收集。<br>算法的描述如图所示：<br><img src="/images/1503390428.png" alt="标记清除算法图"><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3>为了解决效率问题，该算法将内存区域划分为两个相同的部分，记为A和B。一次只使用其中的一半，在需要对A进行垃圾收集时，则将A中存活的对象复制到区域B，然后对A进行清空即可。<br>该算法不会产生碎片，实现简单，运行高效。但是该算法使得可用的内存下降为一半，代价太高了。<br>算法的描述如图所示：<br><img src="/images/1503390682.png" alt="复制算法图"><br>现在的虚拟机通常采用该算法进行新生代的垃圾收集，然而并不是按照1:1的比例来进行内存划分，而是将内存划分为一块较大的<strong>Eden</strong>区和两个较小的<strong>Survivor</strong>区域（如A和B），每次进行内存分配只在<strong>Eden</strong>区和<strong>Survivor A</strong>区进行。当进行垃圾回收时，将上述两个区域中存活的对象全部复制到<strong>Survivor B</strong>区域，最后，对这两个区域进行清空。<br>复制算法存在一种<strong>内存担保</strong>的现象，指的是当<strong>Eden</strong>和<strong>Survivor A</strong>区域存货的对象太多，<strong>Survivor B</strong>中放不下了，那么这些对象将直接进入<strong>老年代</strong>。<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3>复制算法在对象存活率比较高的情况下，效率降低，因此复制算法不适用于<strong>老年代</strong>的垃圾收集。<br>根据老年代的特点，<strong>标记-整理</strong>算法在对存活的对象进行标记后，不是将对象进行清除，而是将对象有序的向一端移动，然后清理掉边界以外的内存。<br>算法的描述图如下：<br><img src="/images/1503391379.png" alt="标记整理图"><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3>分代收集指的是根据Java中不同区域中的对象的生存时间不同，将对象分为<strong>新生代</strong>和<strong>老年代</strong>。针对不同的区域，来使用不同的收集算法。例如：<strong>新生代</strong>每次存活的对象很少，那么就可以采用<strong>复制算法</strong>来对该区域进行垃圾回收；<strong>老年代</strong>每次收集时存活的对象较多，那么就可以采用<strong>标记-清除</strong>或者<strong>标记-整理</strong>算法来进行收集。</li>
</ul>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了Java中的垃圾收集机制以及常见的垃圾收集算法。Java的垃圾收集机制是Java的一个重要特性，用户无需手动释放内存，Java的GC机制能够满足大多数场景对于内存分配的要求。同时，本文在介绍了Java垃圾回收需要解决的问题，即如何判断对象已经可以回收以及如何进行回收（垃圾回收算法）。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yangrubing.github.io/2017/08/22/JVM中的内存区域/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Robin Yang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar/obito.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="月光下的影子">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/22/JVM中的内存区域/" itemprop="url">JVM中的内存区域</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-22T14:51:26+00:00">
                2017-08-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="JVM运行时的数据区域"><a href="#JVM运行时的数据区域" class="headerlink" title="JVM运行时的数据区域"></a>JVM运行时的数据区域</h2><p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。 这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。 根据《Java虚拟机规范（JavaSE 7版）》 的规定，Java虚拟机所管理的内存将会包括以下几个运行时数据区域，如图所示:<br><img src="/images/1503384822.png" alt="jvm运行时数据区"><br>从图中可以看出<strong>方法区</strong>、<strong>堆</strong>由所有的线程共享；<strong>虚拟机栈</strong>、<strong>本地方法栈</strong>、<strong>程序计数器</strong>是线程隔离的。</p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的<strong>行号指示器</strong>。 在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、 循环、 跳转、 异常处理、 线程恢复等基础功能都需要依赖这个计数器来完成。<br>由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。 因此，<strong>为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器</strong>，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“<strong>线程私有</strong>”的内存。<br>如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值则为空（Undefined）。 <strong>此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</strong></p>
<h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><p>与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。 虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储<strong>局部变量表</strong>、 <strong>操作数栈</strong>、 <strong>动态链接</strong>、 <strong>方法出口</strong>等信息。 每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。<br>人们平时所说的栈指的就是虚拟机栈，局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，<strong>这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小</strong>。<br>在此块区域有两种异常情况：</p>
<ul>
<li><code>StackOverflowError</code>异常。如果线程请求的栈深度大于虚拟机所允许的深度。</li>
<li><code>OutOfMemoryError</code>异常。如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可<strong>动态扩展</strong>，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），如果扩展时无法申请到足够的内存，就会抛出<code>OutOfMemoryError</code>异常。</li>
</ul>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p><strong>本地方法栈</strong>（Native Method Stack）与<strong>虚拟机栈</strong>所发挥的作用是非常相似的，它们之间的区别不过是<strong>虚拟机栈</strong>为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。 与虚拟机栈一样，本地方法栈区域也会抛出<code>StackOverflowError</code>和<code>OutOfMemoryError</code>异常。</p>
<h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><ul>
<li>对于大多数应用来说，<strong>Java堆</strong>（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，<strong>在虚拟机启动时创建</strong>。</li>
<li>此内存区域的唯一目的就是存放对象实例，<strong>几乎</strong>所有的对象实例都在这里分配内存。 目前也有栈上分配的一些技术。</li>
<li>从内存回收的角度来看，由于现在收集器基本都采用<strong>分代收集算法</strong>，所以Java堆中还可以细分为：<strong>新生代</strong>和<strong>老年代</strong>；再细致一点的有<strong>Eden</strong>空间、 <strong>From Survivor</strong>空间、<strong> To Survivor</strong>空间等。</li>
<li>从内存分配的角度来看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer<strong>,TLAB</strong>）。 不过无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。 </li>
<li>Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。 在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过<code>-Xmx</code>和<code>-Xms</code>控制）。</li>
<li>如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出<code>OutOfMemoryError</code>异常。<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3>方法区（Method Area）与Java堆一样，是各个<strong>线程共享的内存区域</strong>，它用于存储已被虚拟机加载的<strong>类信息</strong>、 <strong>常量</strong>、 <strong>静态变量</strong>、 <strong>即时编译器编译后的代码</strong>等数据。 虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。当方法区无法满足内存分配需求时，将抛出<code>OutOfMemoryError</code>异常。<br>Java虚拟机规范对方法区的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。 相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。 这区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说，这个区域回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是必要的。 <h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3>运行时常量池（Runtime Constant Pool）是方法区的一部分。 Class文件中除了有类的版本、 字段、 方法、 接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。<br>Java虚拟机对Class文件每一部分（自然也包括常量池）的格式都有严格规定，每一个字节用于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、 装载和执行，但对于运行时常量池，Java虚拟机规范没有做任何细节的要求，不同的提供商实现的虚拟机可以按照自己的需要来实现这个内存区域。 不过，一般来说，除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。<br>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern（）方法。既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出<code>OutOfMemoryError</code>异常。<h3 id="直接内存-NIO分配"><a href="#直接内存-NIO分配" class="headerlink" title="直接内存(NIO分配)"></a>直接内存(NIO分配)</h3>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。 但是这部分内存也被频繁地使用，而且也可能导致<code>OutOfMemoryError</code>异常出现。<br>显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，肯定还是会受到本机总内存（包括RAM以及SWAP区或者分页文件）大小以及处理器寻址空间的限制。 服务器管理员在配置虚拟机参数时，会根据实际内存设置<code>-Xmx</code>等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现<code>OutOfMemoryError</code>异常。<h2 id="Java对象的创建"><a href="#Java对象的创建" class="headerlink" title="Java对象的创建"></a>Java对象的创建</h2></li>
<li>首先，虚拟机遇到一条new指令时，将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、 解析和初始化过。 如果没有，那必须先执行相应的类加载过程。</li>
<li>在类加载检查通过后，接下来虚拟机将为<strong>新生对象分配内存</strong>。对象所需内存的大小在类加载完成后便可完全确定。分配内存的方式有<strong>指针碰撞</strong>和<strong>空闲列表</strong>两种方式。</li>
<li>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值。接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、 如何才能找到类的元数据信息、 对象的哈希码、 对象的GC分代年龄等信息。 </li>
<li>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从Java程序的视角来看，对象创建才刚刚开始——＜init＞方法还没有执行，所有的字段都还为零。执行new指令之后会接着执行＜init＞方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2></li>
<li><a href="https://book.douban.com/subject/6522893/" target="_blank" rel="noopener">深入理解java虚拟机</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yangrubing.github.io/2017/08/22/查询当前的数据库中的表名称/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Robin Yang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar/obito.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="月光下的影子">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/22/查询当前的数据库中的表名称/" itemprop="url">查询当前的数据库中的表名称</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-22T11:43:25+00:00">
                2017-08-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前段时间做项目，需要获取到不同的数据库中，当前登录的用户的表的名称。数据库类型包括<code>MySQL</code>、<code>Oracle</code>、<code>Hive</code>数据库，这三种数据库获取当前表名称的方法不同，总结如下。</p>
<h3 id="Hive获取当前用户的表名称"><a href="#Hive获取当前用户的表名称" class="headerlink" title="Hive获取当前用户的表名称"></a>Hive获取当前用户的表名称</h3><ol>
<li><p>使用<code>show tables</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show tables like &apos;*name*&apos;; -- 显示当前数据库中所有表的名称</span><br></pre></td></tr></table></figure>
</li>
<li><p>由于Hive的元数据是存储在mysql中，可以从元数据库中获取到表的相关信息。获取表的信息主要是从<code>dbs</code>和<code>tbls</code>两个表中获取。两个表中的字段如下图所示：<br><img src="/images/1503373978.png" alt="dbs表中的字段"><br><img src="/images/1503382641.png" alt="tbls表中的字段"></p>
</li>
</ol>
<p>两张表通过<code>db_id</code>这个字段进行连接，可以得到每个库中有那些表:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select b.tbl_name tableName from dbs a join tbls b on(a.db_id = b.db_id) where a.name = ?</span><br></pre></td></tr></table></figure></p>
<h3 id="mysql获取当前库的表名称"><a href="#mysql获取当前库的表名称" class="headerlink" title="mysql获取当前库的表名称"></a>mysql获取当前库的表名称</h3><ol>
<li>mysql也可以用<code>show tables</code>的方式</li>
<li>从<code>information_schema.tables</code>这张表中获取。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select table_name tableName from information_schema.tables s where s.table_schema = database()</span><br><span class="line">-- database()函数为获取当前所用的数据库。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="oracle获取当前用户的表名称"><a href="#oracle获取当前用户的表名称" class="headerlink" title="oracle获取当前用户的表名称"></a>oracle获取当前用户的表名称</h3><p>oracle没有库的概念，oracle的用户相当于库。也就是一个用户下可以有那些表。可以使用如下的sql语句查询：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select table_name tableName from user_tables</span><br></pre></td></tr></table></figure></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="http://blog.csdn.net/lskyne/article/details/38427895" target="_blank" rel="noopener">hive表信息查询：查看表结构、表操作等</a></li>
<li><a href="http://www.cnblogs.com/1130136248wlxk/articles/5517909.html" target="_blank" rel="noopener">[一起学Hive]之十四-Hive的元数据表结构详解</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yangrubing.github.io/2017/08/21/java动态代理总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Robin Yang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar/obito.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="月光下的影子">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/21/java动态代理总结/" itemprop="url">java动态代理总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-21T17:44:09+00:00">
                2017-08-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="动态代理介绍"><a href="#动态代理介绍" class="headerlink" title="动态代理介绍"></a>动态代理介绍</h2><h3 id="什么是java的动态代理机制？"><a href="#什么是java的动态代理机制？" class="headerlink" title="什么是java的动态代理机制？"></a>什么是java的动态代理机制？</h3><blockquote>
<p>Java 动态代理机制的出现，使得 Java 开发人员不用手工编写代理类，只要简单地指定一组接口及委托类对象，便能动态地获得代理类。代理类会负责将所有的方法调用分派到委托对象上反射执行，在分派执行的过程中，开发人员还可以按需调整委托类对象及其功能，这是一套非常灵活有弹性的代理框架。</p>
</blockquote>
<p>通过Java的动态代理，我们可以使用一个代理对象来增强一个目标对象的功能。例如Spring的AOP就是基于动态代理实现的，通过动态代理，我们可以在每个方法之前或者之后进行额外的处理，最常见的有<strong>事务管理</strong>、<strong>日志记录</strong>等功能。</p>
<h3 id="设计模式之代理模式？"><a href="#设计模式之代理模式？" class="headerlink" title="设计模式之代理模式？"></a>设计模式之代理模式？</h3><p>代理是一种常用的设计模式，其目的就是为需要代理的对象提供一个代理，以控制对某个对象的访问。代理类可以为目标类进行预处理、过滤转发等操作。<br><img src="/images/2017-08-21-17-49-33.jpg" alt><br>如上图所示，代理模式的Client向Subject对象发送一个请求，代理类ProxySubject将替代RealSubject进行处理。可以看出ProxySubject除了doSomething()方法之外还可以doOtherThing()，在不需要修改类的源码时增强了类的功能。<br>通过代理类这中间一层，能有效控制对委托类对象的直接访问，也可以很好地隐藏和保护委托类对象，同时也为实施不同控制策略预留了空间，从而在设计上获得了更大的灵活性。Java 动态代理机制以巧妙的方式近乎完美地实践了代理模式的设计理念。</p>
<h2 id="java动态代理的实现"><a href="#java动态代理的实现" class="headerlink" title="java动态代理的实现"></a>java动态代理的实现</h2><h3 id="相关的类和接口"><a href="#相关的类和接口" class="headerlink" title="相关的类和接口"></a>相关的类和接口</h3><p>要了解 Java 动态代理的机制，首先需要了解以下相关的类或接口。</p>
<ul>
<li><p><strong><code>java.lang.reflect.Proxy</code></strong>：这是 Java 动态代理机制的主类，它提供了一组静态方法来为一组接口动态地生成代理类及其对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法 1: 该方法用于获取指定代理对象所关联的调用处理器</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> InvocationHandler <span class="title">getInvocationHandler</span><span class="params">(Object proxy)</span> </span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="comment">// 方法 2：该方法用于获取关联于指定类装载器和一组接口的动态代理类的类对象</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Class <span class="title">getProxyClass</span><span class="params">(ClassLoader loader, Class[] interfaces)</span> </span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="comment">// 方法 3：该方法用于判断指定类对象是否是一个动态代理类</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isProxyClass</span><span class="params">(Class cl)</span> </span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="comment">// 方法 4：该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, Class[] interfaces, </span></span></span><br><span class="line"><span class="function"><span class="params">    InvocationHandler h)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>java.lang.reflect.InvocationHandler</code></strong>：这是调用处理器接口，它自定义了一个 invoke 方法，用于集中处理在动态代理类对象上的方法调用，通常在该方法中实现对目标类的代理访问。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该方法负责集中处理动态代理类上的所有方法调用。</span></span><br><span class="line"><span class="comment">// 第一个参数既是代理类实例，</span></span><br><span class="line"><span class="comment">// 第二个参数是被调用的方法对象,第三个参数是调用参数。</span></span><br><span class="line"><span class="comment">// 调用处理器根据这三个参数进行预处理或分派到委托类实例上执行</span></span><br><span class="line"><span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>每次生成动态代理类对象时，都需要指定一个实现了<code>InvocationHandler</code>调用处理器对象。</p>
<ul>
<li><strong><code>java.lang.ClassLoader</code></strong>：这是类装载器类，负责将类的字节码装载到 Java 虚拟机（JVM）中并为其定义类对象，然后该类才能被使用。Proxy 静态方法生成动态代理类同样需要通过类装载器来进行装载才能使用，它与普通类的唯一区别就是<strong>其字节码是由 JVM 在运行时动态生成的而非预存在于任何一个 .class 文件中</strong>。</li>
</ul>
<h3 id="java动态代理的步骤以及特点"><a href="#java动态代理的步骤以及特点" class="headerlink" title="java动态代理的步骤以及特点"></a>java动态代理的步骤以及特点</h3><h4 id="Java动态代理的步骤"><a href="#Java动态代理的步骤" class="headerlink" title="Java动态代理的步骤"></a>Java动态代理的步骤</h4><ol>
<li>通过实现 InvocationHandler 接口创建自己的调用处理器；</li>
<li>通过为 Proxy 类指定 ClassLoader 对象和一组 interface 来创建动态代理类；</li>
<li>通过反射机制获得动态代理类的构造函数，其唯一参数类型是调用处理器接口类型；</li>
<li>通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数被传入。<br>代码如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其内部通常包含指向委托类实例的引用，用于真正执行分派转发过来的方法调用</span></span><br><span class="line">InvocationHandler handler = <span class="keyword">new</span> InvocationHandlerImpl(..); </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 通过 Proxy 为包括 Interface 接口在内的一组接口动态创建代理类的类对象</span></span><br><span class="line">Class clazz = Proxy.getProxyClass(classLoader, <span class="keyword">new</span> Class[] &#123; Interface.class, ... &#125;); </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 通过反射从生成的类对象获得构造函数对象</span></span><br><span class="line">Constructor constructor = clazz.getConstructor(<span class="keyword">new</span> Class[] &#123; InvocationHandler.class &#125;); </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 通过构造函数对象创建动态代理类实例</span></span><br><span class="line">Interface Proxy = (Interface)constructor.newInstance(<span class="keyword">new</span> Object[] &#123; handler &#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>实际使用过程更加简单，因为 Proxy 的静态方法 newProxyInstance 已经为我们封装了步骤 2 到步骤 4 的过程，所以简化后的过程如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InvocationHandlerImpl 实现了 InvocationHandler 接口，并能实现方法调用从代理类到委托类的分派转发</span></span><br><span class="line">InvocationHandler handler = <span class="keyword">new</span> InvocationHandlerImpl(..); </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 通过 Proxy 直接创建动态代理类实例</span></span><br><span class="line">Interface proxy = (Interface)Proxy.newProxyInstance( classLoader, </span><br><span class="line">     <span class="keyword">new</span> Class[] &#123; Interface.class &#125;, </span><br><span class="line">     handler );</span><br></pre></td></tr></table></figure></p>
<h4 id="Java动态代理类本身的特点"><a href="#Java动态代理类本身的特点" class="headerlink" title="Java动态代理类本身的特点"></a>Java动态代理类本身的特点</h4><ol>
<li><strong>包</strong>：如果所代理的接口都是 public 的，那么它将被定义在顶层包（即包路径为空）;如果所代理的接口中有非 public 的接口（因为接口不能被定义为 protect 或 private，所以除 public 之外就是默认的 package 访问级别），那么它将被定义在该接口所在包,这样设计的目的是为了最大程度的保证动态代理类不会因为包管理的问题而无法被成功定义并访问；</li>
<li><strong>类修饰符</strong>：该代理类具有 final 和 public 修饰符，意味着它可以被所有的类访问，但是不能被再度继承；</li>
<li><strong>类名</strong>：格式是“$ProxyN”，其中 N 是一个逐一递增的阿拉伯数字，代表 Proxy 类第 N 次生成的动态代理类，值得注意的一点是，并不是每次调用 Proxy 的静态方法创建动态代理类都会使得 N 值增加，原因是如果对同一组接口（包括接口排列的顺序相同）试图重复创建动态代理类，它会很聪明地返回先前已经创建好的代理类的类对象，而不会再尝试去创建一个全新的代理类.</li>
<li>生成的代理类的继承关系<br><img src="/images/2017-08-21-18-25-29.jpg" alt="生成的代理类的继承关系"><br>从图中可以看出，所有的代理类都继承自Proxy基类，并实现了代理的接口。</li>
</ol>
<h4 id="代理类实例的一些特点"><a href="#代理类实例的一些特点" class="headerlink" title="代理类实例的一些特点"></a>代理类实例的一些特点</h4><ol>
<li>每个实例都会关联一个调用处理器对象，可以通过 Proxy 提供的静态方法 getInvocationHandler 去获得代理类实例的调用处理器对象。在代理类实例上调用其代理的接口中所声明的方法时，这些方法最终都会由调用处理器的 invoke 方法执行。</li>
<li>值得注意的是，<strong>代理类的根类 java.lang.Object 中有三个方法也同样会被分派到调用处理器的 invoke 方法执行，它们是 hashCode，equals 和 toString，可能的原因有：一是因为这些方法为 public 且非 final 类型，能够被代理类覆盖；二是因为这些方法往往呈现出一个类的某种特征属性，具有一定的区分度，所以为了保证代理类与委托类对外的一致性，这三个方法也应该被分派到委托类执行。</strong></li>
<li>当代理的一组接口有重复声明的方法且该方法被调用时，代理类总是从排在<strong>最前面</strong>的接口中获取方法对象并分派给调用处理器，而无论代理类实例是否正在以该接口（或继承于该接口的某子接口）的形式被外部引用，因为在代理类内部无法区分其当前的被引用类型。</li>
</ol>
<h4 id="异常处理的特点"><a href="#异常处理的特点" class="headerlink" title="异常处理的特点"></a>异常处理的特点</h4><p>从调用处理器接口声明的方法中可以看到理论上它能够抛出任何类型的异常，因为所有的异常都继承于 Throwable 接口，但事实是否如此呢？答案是否定的，<strong>原因是我们必须遵守一个继承原则：即子类覆盖父类或实现父接口的方法时，抛出的异常必须在原方法支持的异常列表之内。</strong>所以虽然调用处理器理论上讲能够，但实际上往往受限制，除非父接口中的方法支持抛 Throwable 异常。那么如果在 invoke 方法中的确产生了接口方法声明中不支持的异常，那将如何呢？放心，Java 动态代理类已经为我们设计好了解决方法：它将会抛出 <code>UndeclaredThrowableException</code> 异常。这个异常是一个 RuntimeException 类型，所以不会引起编译错误。通过该异常的 getCause 方法，还可以获得原来那个不受支持的异常对象，以便于错误诊断。</p>
<h3 id="动态代理的实现分析"><a href="#动态代理的实现分析" class="headerlink" title="动态代理的实现分析"></a>动态代理的实现分析</h3><p>首先，咱们来看看Proxy的构造方法。Proxy类有两个构造方法，一个无参的私有构造方法，以及一个protect的参数为一个InvocationHandler的构造方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于 Proxy 内部从不直接调用构造函数，所以 private 类型意味着禁止任何调用</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Proxy</span><span class="params">()</span> </span>&#123;&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于 Proxy 内部从不直接调用构造函数，所以 protected 意味着只有子类可以调用</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">Proxy</span><span class="params">(InvocationHandler h)</span> </span>&#123;<span class="keyword">this</span>.h = h;&#125;</span><br></pre></td></tr></table></figure></p>
<p>再来看看Proxy对象最核心的创建代理对象的Proxy.newInstance(ClassLoader classLoader, Class&lt;?&gt;[] interfaces, InvocationHandler h )方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *   返回指定接口的代理类的实例将方法调用分派给指定的调用处理程序。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   loader 定义代理类的classloader</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   interfaces 代理类实现的接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   h 该代理类指定的InvocationHandler</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>   通过给定的invocationHandler，返回一个代理实例。这个代理实例是由</span></span><br><span class="line"><span class="comment"> * classoader来定义，并且实现了指定的接口</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      InvocationHandler h)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//首先校验InvocationHandler是否为null，如果为null则抛出npe    </span></span><br><span class="line">    Objects.requireNonNull(h);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取要实现的接口</span></span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line">    <span class="comment">//系统安全检查</span></span><br><span class="line">    <span class="keyword">final</span> SecurityManager sm = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">        checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 查找或生成指定的代理类的Class对象。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *通过指定的InvocationHandler来构造代理类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取到代理类的构造函数，</span></span><br><span class="line">        <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">        <span class="keyword">final</span> InvocationHandler ih = h;</span><br><span class="line">        <span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 并通过构造函数来生成代理类的实例</span></span><br><span class="line">        <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> Object[]&#123;h&#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException|InstantiationException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        Throwable t = e.getCause();</span><br><span class="line">        <span class="keyword">if</span> (t <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (RuntimeException) t;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(t.toString(), t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="java动态代理存在的问题"><a href="#java动态代理存在的问题" class="headerlink" title="java动态代理存在的问题"></a>java动态代理存在的问题</h3><p>诚然，Proxy 已经设计得非常优美，但是还是有一点点小小的遗憾之处，<strong>那就是它始终无法摆脱仅支持 interface 代理的桎梏，因为它的设计注定了这个遗憾</strong>。回想一下那些动态生成的代理类的继承关系图，它们已经注定有一个共同的父类叫 Proxy。Java 的继承机制注定了这些动态代理类们无法实现对 class 的动态代理，<strong>原因是多继承在 Java 中本质上就行不通。</strong><br>有很多条理由，人们可以否定对 class 代理的必要性，但是同样有一些理由，相信支持 class 动态代理会更美好。接口和类的划分，本就不是很明显，只是到了 Java 中才变得如此的细化。如果只从方法的声明及是否被定义来考量，有一种两者的混合体，它的名字叫抽象类。实现对抽象类的动态代理，相信也有其内在的价值。<strong>此外，还有一些历史遗留的类，它们将因为没有实现任何接口而从此与动态代理永世无缘。如此种种，不得不说是一个小小的遗憾。</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yangrubing.github.io/2017/08/18/编程原则/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Robin Yang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar/obito.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="月光下的影子">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/18/编程原则/" itemprop="url">编程原则</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-18T14:42:59+00:00">
                2017-08-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原始链接<a href="http://java-design-patterns.com/principles/#law-of-demeter" target="_blank" rel="noopener">principle</a></p>
<blockquote>
<p>每一个程序员都应该理解并使用编程原则以及设计模式，并能从中受益。</p>
</blockquote>
<h1 id="通用原则"><a href="#通用原则" class="headerlink" title="通用原则"></a>通用原则</h1><h2 id="KISS-Keep-It-Simple-Stupid"><a href="#KISS-Keep-It-Simple-Stupid" class="headerlink" title="KISS(Keep It Simple Stupid)"></a>KISS(Keep It Simple Stupid)</h2><blockquote>
<p>大多数系统在保持简单而不是复杂的情况下运行得最好。</p>
</blockquote>
<h3 id="为什么这么做"><a href="#为什么这么做" class="headerlink" title="为什么这么做"></a>为什么这么做</h3><ul>
<li>代码越少，编写的时间就越少，bug也就越少，并且更容易修改。</li>
<li>Simplicity is the ultimate sophistication.（简化是最终的高雅？）</li>
<li>完美并不是说系统达到了无法添加的程度，而是指达到了没有任何可以继续简化的程度。<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3></li>
<li><a href="http://en.wikipedia.org/wiki/KISS_principle" target="_blank" rel="noopener">KISS Principle</a></li>
<li><a href="http://principles-wiki.net/principles:keep_it_simple_stupid" target="_blank" rel="noopener">Keep It Simple Stupid (KISS)</a><h2 id="YAGNI-You-aren’t-gonna-need-it"><a href="#YAGNI-You-aren’t-gonna-need-it" class="headerlink" title="YAGNI(You aren’t gonna need it)"></a>YAGNI(You aren’t gonna need it)</h2><blockquote>
<p>不要实现没有必要实现的东西。</p>
</blockquote>
</li>
</ul>
<h3 id="为什么这么做-1"><a href="#为什么这么做-1" class="headerlink" title="为什么这么做"></a>为什么这么做</h3><ul>
<li>为了完成以后需要来完成的功能付出努力，意味着你会减低为当前迭代周期付出的努力。</li>
<li>可能会导致代码膨胀，软件将会变得越来越复杂。<h3 id="如何做"><a href="#如何做" class="headerlink" title="如何做"></a>如何做</h3></li>
<li>只实现当前系统中必须实现的东西而不是那些你所能遇见到的将来可能会需要来实现的，那些东西以后再实现。<h3 id="参考资料-1"><a href="#参考资料-1" class="headerlink" title="参考资料"></a>参考资料</h3></li>
<li><a href="http://c2.com/xp/YouArentGonnaNeedIt.html" target="_blank" rel="noopener">http://c2.com/xp/YouArentGonnaNeedIt.html</a></li>
<li><a href="http://www.xprogramming.com/Practices/PracNotNeed.html" target="_blank" rel="noopener">http://www.xprogramming.com/Practices/PracNotNeed.html</a></li>
<li><a href="http://en.wikipedia.org/wiki/You_ain&#39;t_gonna_need_it" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/You_ain’t_gonna_need_it</a></li>
</ul>
<h2 id="做最简单的事-Do-The-Simplest-Thing-That-Could-Possibly-Work"><a href="#做最简单的事-Do-The-Simplest-Thing-That-Could-Possibly-Work" class="headerlink" title="做最简单的事(Do The Simplest Thing That Could Possibly Work)"></a>做最简单的事(Do The Simplest Thing That Could Possibly Work)</h2><h3 id="为什么这么做-2"><a href="#为什么这么做-2" class="headerlink" title="为什么这么做"></a>为什么这么做</h3><ul>
<li>为这个问题寻找最简单的解决方案，而不是将他复杂化。这样我们可以回归到问题的本身。<h3 id="如何做-1"><a href="#如何做-1" class="headerlink" title="如何做"></a>如何做</h3></li>
<li>问你自己：“解决这个问题最简单的方案是什么？“<h3 id="参考资料-2"><a href="#参考资料-2" class="headerlink" title="参考资料"></a>参考资料</h3></li>
<li><a href="http://c2.com/xp/DoTheSimplestThingThatCouldPossiblyWork.html" target="_blank" rel="noopener">Do The Simplest Thing That Could Possibly Work</a></li>
</ul>
<h2 id="关注点分离-Separation-of-Concerns"><a href="#关注点分离-Separation-of-Concerns" class="headerlink" title="关注点分离(Separation of Concerns)"></a>关注点分离(Separation of Concerns)</h2><p>关注点分离是一种设计原则，用于将计算机程序分离成不同的部分，这样每个部分都处理一个单独的关注点。例如，应用程序的业务逻辑是一个令人关注的问题，而用户界面则是另一个关注点。更改用户界面不需要对业务逻辑进行更改，反之亦然。<br><a href="https://en.wikipedia.org/wiki/Edsger_W._Dijkstra" target="_blank" rel="noopener">Edsger W. Dijkstra</a></p>
<blockquote>
<p>It is what I sometimes have called “the separation of concerns”, which, even if not perfectly possible, is yet the only available technique for effective ordering of one’s thoughts, that I know of. This is what I mean by “focusing one’s attention upon some aspect”: it does not mean ignoring the other aspects, it is just doing justice to the fact that from this aspect’s point of view, the other is irrelevant.</p>
</blockquote>
<h3 id="为什么这么做-3"><a href="#为什么这么做-3" class="headerlink" title="为什么这么做"></a>为什么这么做</h3><ul>
<li>简化软件应用程序的开发和维护</li>
<li>当关注点分离时，单独的部分可以被<strong>重用</strong>，也可以独立地<strong>开发</strong>和<strong>更新</strong>。<h3 id="如何做-2"><a href="#如何做-2" class="headerlink" title="如何做"></a>如何做</h3></li>
<li>将程序功能分解成多个模块，尽可能少地重叠。但是也要注意别分的太散，不然将带来更大的复杂度。<h3 id="参考资料-3"><a href="#参考资料-3" class="headerlink" title="参考资料"></a>参考资料</h3></li>
<li><a href="https://en.wikipedia.org/wiki/Separation_of_concerns" target="_blank" rel="noopener">Separation of Concerns</a><h2 id="保持代码干燥，尽量减少重复代码-Keep-Things-DRY"><a href="#保持代码干燥，尽量减少重复代码-Keep-Things-DRY" class="headerlink" title="保持代码干燥，尽量减少重复代码(Keep Things DRY)"></a>保持代码干燥，尽量减少重复代码(Keep Things DRY)</h2>程序中的每一个部分都必须在一个系统中是单一的、明确的、权威的表示。程序中的每一项重要功能都应该只在一个地方实现。在不同的代码片段中执行相似的功能时，将他们重合的部分提取出来。<h3 id="为什么这么做-4"><a href="#为什么这么做-4" class="headerlink" title="为什么这么做"></a>为什么这么做</h3></li>
<li>重复(无意的或有目的的重复)会导致代码难以维护、分解以及逻辑上的矛盾。</li>
<li>对系统中的任何单个功能进行修改时，不需要对其他逻辑无关的功能代码进行更改。</li>
<li>此外，逻辑上相关的代码的改变都是可预测以及一致的，因此需要保持同步。<h3 id="如何做-3"><a href="#如何做-3" class="headerlink" title="如何做"></a>如何做</h3></li>
<li>将业务规则、长表达式、if语句、数学公式、元数据等放在一个地方。</li>
<li>确定系统中所使用的单一的、确定性的知识源，然后使用该源生成该知识的可应用实例(代码、文档、测试等)</li>
<li>应用 <a href="http://en.wikipedia.org/wiki/Rule_of_three_(computer_programming" target="_blank" rel="noopener">Rule of three原则</a>).<h3 id="参考资料-4"><a href="#参考资料-4" class="headerlink" title="参考资料"></a>参考资料</h3></li>
<li><a href="http://c2.com/cgi/wiki?DontRepeatYourself" target="_blank" rel="noopener">Dont Repeat Yourself</a><h2 id="写代码的时候考虑代码的可维护性-Code-For-The-Maintainer"><a href="#写代码的时候考虑代码的可维护性-Code-For-The-Maintainer" class="headerlink" title="写代码的时候考虑代码的可维护性(Code For The Maintainer)"></a>写代码的时候考虑代码的可维护性(Code For The Maintainer)</h2><h3 id="为什么这么做-5"><a href="#为什么这么做-5" class="headerlink" title="为什么这么做"></a>为什么这么做</h3></li>
<li>到目前为止，维护是任何项目中最昂贵的阶段。<h3 id="如何做-4"><a href="#如何做-4" class="headerlink" title="如何做"></a>如何做</h3></li>
<li>成为一个代码的维护者。</li>
<li>把维护你的代码的人想象成一个知道你住处的精神病患者，如果你的代码写的不好随时都可能过来干掉你。</li>
<li>确定系统中所使用的单一的、确定性的知识源，然后使用该源生成该知识的可应用实例(代码、文档、测试等)</li>
<li>良好的编写代码和注释，如果一个新手拿起代码，他们就会乐于阅读和学习。</li>
<li><a href="http://www.sensible.com/dmmt.html" target="_blank" rel="noopener">Don’t make me think.</a></li>
<li>Use <a href="http://en.wikipedia.org/wiki/Principle_of_least_astonishment" target="_blank" rel="noopener">the Principle of Least Astonishment</a><h3 id="参考资料-5"><a href="#参考资料-5" class="headerlink" title="参考资料"></a>参考资料</h3></li>
<li><a href="http://c2.com/cgi/wiki?CodeForTheMaintainer" target="_blank" rel="noopener">http://c2.com/cgi/wiki?CodeForTheMaintainer</a></li>
<li><a href="http://blog.codinghorror.com/the-noble-art-of-maintenance-programming/" target="_blank" rel="noopener">http://blog.codinghorror.com/the-noble-art-of-maintenance-programming/</a></li>
</ul>
<h2 id="避免过早优化-Avoid-Premature-Optimization"><a href="#避免过早优化-Avoid-Premature-Optimization" class="headerlink" title="避免过早优化(Avoid Premature Optimization)"></a>避免过早优化(Avoid Premature Optimization)</h2><p>Donald Knuth:</p>
<blockquote>
<p>程序员浪费了大量的时间去思考，或者担心他们的程序的非关键部分的速度。而当考虑到调试和维护时，这些效率的尝试实际上会产生强烈的负面影响。我们应该忘记小的效率，大约97%的时间:过早的优化是所有邪恶的根源。然而，我们不应在那关键的3%中放弃我们的机会。</p>
</blockquote>
<p>当然，理解什么不是“过早”是至关重要的</p>
<h3 id="为什么这么做-6"><a href="#为什么这么做-6" class="headerlink" title="为什么这么做"></a>为什么这么做</h3><ul>
<li>在开发的早期，影响系统性能的问题并不会浮现的很清楚。</li>
<li>在优化之后，代码可能更难读懂和维护。<h3 id="如何做-5"><a href="#如何做-5" class="headerlink" title="如何做"></a>如何做</h3></li>
<li><a href="http://c2.com/cgi/wiki?MakeItWorkMakeItRightMakeItFast" target="_blank" rel="noopener">Make It Work Make It Right Make It Fast</a></li>
<li>只有在你真正需要的时候才去优化代码，并且在你明白系统的瓶颈后才去优化他。<h3 id="参考资料-6"><a href="#参考资料-6" class="headerlink" title="参考资料"></a>参考资料</h3></li>
<li><a href="http://en.wikipedia.org/wiki/Program_optimization" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Program_optimization</a></li>
<li><a href="http://c2.com/cgi/wiki?PrematureOptimization" target="_blank" rel="noopener">http://c2.com/cgi/wiki?PrematureOptimization</a><h2 id="重构代码时需要考虑的问题——童子军原则-Boy-Scout-Rule"><a href="#重构代码时需要考虑的问题——童子军原则-Boy-Scout-Rule" class="headerlink" title="重构代码时需要考虑的问题——童子军原则(Boy-Scout Rule)"></a>重构代码时需要考虑的问题——童子军原则(Boy-Scout Rule)</h2><h3 id="为什么这么做-7"><a href="#为什么这么做-7" class="headerlink" title="为什么这么做"></a>为什么这么做</h3></li>
<li>当对现有代码库进行更改时，有可能会降低代码的质量。<h3 id="如何做-6"><a href="#如何做-6" class="headerlink" title="如何做"></a>如何做</h3></li>
<li>确保每次提交都不会降低代码的质量。</li>
<li>当看到一些代码不像它应该的那样清晰，应该设法修复它。<h3 id="参考资料-7"><a href="#参考资料-7" class="headerlink" title="参考资料"></a>参考资料</h3></li>
<li><a href="http://martinfowler.com/bliki/OpportunisticRefactoring.html" target="_blank" rel="noopener">http://martinfowler.com/bliki/OpportunisticRefactoring.html</a><h1 id="模块与模块-类与类-之间的设计原则（Inter-Module-Class"><a href="#模块与模块-类与类-之间的设计原则（Inter-Module-Class" class="headerlink" title="模块与模块(类与类)之间的设计原则（Inter-Module/Class)"></a>模块与模块(类与类)之间的设计原则（Inter-Module/Class)</h1><h2 id="最小化代码的耦合程度-Minimise-Coupling"><a href="#最小化代码的耦合程度-Minimise-Coupling" class="headerlink" title="最小化代码的耦合程度(Minimise Coupling)"></a>最小化代码的耦合程度(Minimise Coupling)</h2>模块/组件之间的耦合是它们相互依赖的程度;低耦合是更好的。换句话说，耦合就是在修改模块A后模块B”中断“的概率。<h3 id="为什么这么做-8"><a href="#为什么这么做-8" class="headerlink" title="为什么这么做"></a>为什么这么做</h3></li>
<li>一个模块的更改通常会导致其他模块的更改产生连锁反应。</li>
<li>模块的组合可能需要更多的努力和/或时间，因为模块之间的依赖性增加了。</li>
<li>由于必须包含依赖模块，一个特定的模块可能更难复用和测试。</li>
<li>开发人员可能害怕更改代码，因为他们不确定可能会带来什么影响。<h3 id="如何做-7"><a href="#如何做-7" class="headerlink" title="如何做"></a>如何做</h3></li>
<li>消除、最小化和减少必要的关系的复杂性。</li>
<li>通过隐藏实现的细节，耦合程度就降低了。</li>
<li>应用迪米特法则(<a href="http://java-design-patterns.com/principles/#law-of-demeter" target="_blank" rel="noopener">迪米特法则</a>)。<h3 id="参考资料-8"><a href="#参考资料-8" class="headerlink" title="参考资料"></a>参考资料</h3></li>
<li><a href="http://en.wikipedia.org/wiki/Coupling_(computer_programming" target="_blank" rel="noopener">Coupling</a>)</li>
<li><a href="http://c2.com/cgi/wiki?CouplingAndCohesion" target="_blank" rel="noopener">Coupling And Cohesion</a></li>
</ul>
<h2 id="迪米特法则-Law-of-Demeter"><a href="#迪米特法则-Law-of-Demeter" class="headerlink" title="(迪米特法则)Law of Demeter"></a>(迪米特法则)Law of Demeter</h2><p>不要和陌生人说话（Don’t talk to strangers）</p>
<h3 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h3><ul>
<li>这样做会增加了耦合的程度</li>
<li>这样做会暴露太多的实现细节<h3 id="如何做-8"><a href="#如何做-8" class="headerlink" title="如何做"></a>如何做</h3></li>
<li>限制一个对象中的方法，让它只能访问：<ul>
<li>这个对象本身</li>
<li>这个方法的参数</li>
<li>在这个方法中创建的对象</li>
<li>这个对象的属性和域。<h3 id="参考资料-9"><a href="#参考资料-9" class="headerlink" title="参考资料"></a>参考资料</h3></li>
</ul>
</li>
<li><a href="http://en.wikipedia.org/wiki/Law_of_Demeter" target="_blank" rel="noopener">迪米特法则</a></li>
<li><a href="http://haacked.com/archive/2009/07/14/law-of-demeter-dot-counting.aspx/" target="_blank" rel="noopener">The Law of Demeter Is Not A Dot Counting Exercise</a></li>
</ul>
<h2 id="组合优先用于继承-Composition-Over-Inheritance"><a href="#组合优先用于继承-Composition-Over-Inheritance" class="headerlink" title="组合优先用于继承(Composition Over Inheritance)"></a>组合优先用于继承(Composition Over Inheritance)</h2><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><ul>
<li>降低类之间的耦合</li>
<li>使用继承，子类可以轻松地做出假设，并打破里氏替换原则(LSP)。<h3 id="如何做-9"><a href="#如何做-9" class="headerlink" title="如何做"></a>如何做</h3></li>
<li>对LSP(可替代性)进行测试，以决定什么时候继承。</li>
<li>当两个类之间的关系是”has a”或者”uses a”时使用组合，当时”is a”时才使用继承。<h3 id="参考资料-10"><a href="#参考资料-10" class="headerlink" title="参考资料"></a>参考资料</h3></li>
<li><a href="http://blogs.msdn.com/b/thalesc/archive/2012/09/05/favor-composition-over-inheritance.aspx" target="_blank" rel="noopener">Favor Composition Over Inheritance</a><h2 id="正交原则-Orthogonality"><a href="#正交原则-Orthogonality" class="headerlink" title="正交原则(Orthogonality)"></a>正交原则(Orthogonality)</h2><blockquote>
<p>正交性的基本概念是，在概念上不相关的事物在系统中也应该是不相关的。<br>正交性与简单性有关：设计越正交，异常就越少。这使得用编程语言学习、阅读和编写程序变得更加容易。正交特征的意义是独立于上下文的；关键的参数是对称性和一致性。</p>
</blockquote>
</li>
</ul>
<h2 id="鲁棒性原则-Robustness-Principle"><a href="#鲁棒性原则-Robustness-Principle" class="headerlink" title="(鲁棒性原则) Robustness Principle"></a>(鲁棒性原则) Robustness Principle</h2><blockquote>
<p>Be conservative in what you do, be liberal in what you accept from others</p>
</blockquote>
<h3 id="原因-1"><a href="#原因-1" class="headerlink" title="原因"></a>原因</h3><ul>
<li>为了能够改进服务，您需要确保服务提供者能够做出更改以支持新需求，同时对现有客户造成最小的破坏。<h3 id="如何做-10"><a href="#如何做-10" class="headerlink" title="如何做"></a>如何做</h3></li>
<li>向其他机器发送命令或数据的代码(或在同一台机器上的其他程序)应该完全符合规范，但是接收输入的服务应该接受不符合条件的输入，只要其含义是明确的。（在输入不符合规范时，也能够进行处理）。<h2 id="控制反转-Inversion-of-Control"><a href="#控制反转-Inversion-of-Control" class="headerlink" title="控制反转(Inversion of Control)"></a>控制反转(Inversion of Control)</h2><blockquote>
<p>控制反转是一种设计原则，他能够在一个框架中，将自定义的功能交由一个容器来控制。控制反转使得可重用代码和解决特定问题的代码可以同时使用，并让他们可以在一个应用中进行协作，降低了系统的耦合。</p>
</blockquote>
</li>
</ul>
<h3 id="控制反转好处"><a href="#控制反转好处" class="headerlink" title="控制反转好处"></a>控制反转好处</h3><ul>
<li><strong>控制反转是用来提高系统的模块化，并使得系统更容易拓展</strong>。</li>
<li>将任务的执行和实现进行了分离。</li>
<li>将一个模块集中在它所实现的任务上。</li>
<li>将模块从假设中解放出来，不依赖其他系统是如何做的，而是依赖于合同。</li>
<li>防止更换模块产生的副作用。<h3 id="控制反转实现方法"><a href="#控制反转实现方法" class="headerlink" title="控制反转实现方法"></a>控制反转实现方法</h3></li>
<li>使用工厂模式（ Service Locator pattern）</li>
<li>使用服务定位器模式（ Service Locator pattern）</li>
<li>使用依赖注入（Dependency Injection）</li>
<li>使用上下文查找（Dependency Injection）</li>
<li>使用模板方法模式（Template Method pattern）</li>
<li>使用策略模式（Strategy pattern）<h3 id="参考资料-11"><a href="#参考资料-11" class="headerlink" title="参考资料"></a>参考资料</h3></li>
<li><a href="https://en.wikipedia.org/wiki/Inversion_of_control" target="_blank" rel="noopener">Inversion of Control in Wikipedia</a></li>
<li><a href="https://www.martinfowler.com/articles/injection.html" target="_blank" rel="noopener">Inversion of Control Containers and the Dependency Injection pattern</a><h1 id="模块-类的设计原则（Module-Class"><a href="#模块-类的设计原则（Module-Class" class="headerlink" title="模块/类的设计原则（Module/Class)"></a>模块/类的设计原则（Module/Class)</h1><h2 id="高内聚-Maximise-Cohesion"><a href="#高内聚-Maximise-Cohesion" class="headerlink" title="高内聚(Maximise Cohesion)"></a>高内聚(Maximise Cohesion)</h2><blockquote>
<p>Cohesion of a single module/component is the degree to which its responsibilities form a meaningful unit; higher cohesion is better.</p>
</blockquote>
</li>
</ul>
<h3 id="高内聚的缺点"><a href="#高内聚的缺点" class="headerlink" title="高内聚的缺点"></a>高内聚的缺点</h3><ul>
<li>增加了理解模块的难度。</li>
<li>系统维护的难度增加了，因为域的逻辑变化会影响多个模块，并且一个模块的更改可能会需要相关模块的更改。</li>
<li>重用模块的难度增加，因为大多数应用程序不需要模块提供的随机操作集。<h3 id="实现高内聚"><a href="#实现高内聚" class="headerlink" title="实现高内聚"></a>实现高内聚</h3></li>
<li>将相关联的功能聚合在一起，比如说一个class中。<h2 id="里氏替换原则-Liskov-Substitution-Principle"><a href="#里氏替换原则-Liskov-Substitution-Principle" class="headerlink" title="里氏替换原则(Liskov Substitution Principle)"></a>里氏替换原则(Liskov Substitution Principle)</h2><blockquote>
<p>Objects in a program should be replaceable with instances of their subtypes without altering the correctness of that program.</p>
</blockquote>
</li>
</ul>
<p><strong>java中的多态，父类引用指向子类对象。</strong></p>
<h3 id="参考资料-12"><a href="#参考资料-12" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="http://en.wikipedia.org/wiki/Liskov_substitution_principle" target="_blank" rel="noopener">Liskov substitution principle</a></li>
<li><a href="http://www.blackwasp.co.uk/lsp.aspx" target="_blank" rel="noopener">Liskov Substitution Principle</a><h2 id="开闭原则-Open-Closed-Principle"><a href="#开闭原则-Open-Closed-Principle" class="headerlink" title="开闭原则(Open/Closed Principle)"></a>开闭原则(Open/Closed Principle)</h2>类在设计时应该对<strong>继承</strong>开放，并且对<strong>修改</strong>封闭。这样的类可以在不修改源代码的情况下修改其行为。<h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3></li>
<li>通过对当前的代码改变最小，提高了系统的可维护性和稳定性。<h3 id="如何做-11"><a href="#如何做-11" class="headerlink" title="如何做"></a>如何做</h3></li>
<li>编写可以扩展的类(而不是可以修改的类)。</li>
<li>只暴露需要更改的移动部分，隐藏其他所有内容。<h3 id="参考资料-13"><a href="#参考资料-13" class="headerlink" title="参考资料"></a>参考资料</h3></li>
<li><a href="http://en.wikipedia.org/wiki/Open/closed_principle" target="_blank" rel="noopener">Open Closed Principle</a></li>
<li><a href="https://8thlight.com/blog/uncle-bob/2014/05/12/TheOpenClosedPrinciple.html" target="_blank" rel="noopener">The Open Closed Principle</a><h2 id="单一职责原则-Single-Responsibility-Principle"><a href="#单一职责原则-Single-Responsibility-Principle" class="headerlink" title="单一职责原则(Single Responsibility Principle)"></a>单一职责原则(Single Responsibility Principle)</h2>一个类永远不应该有超过一个理由去改变。<br>每个类都应该有一个单独的职责，而这个职责应该完全由类来封装，而且只有这一个职责、<h3 id="好处-1"><a href="#好处-1" class="headerlink" title="好处"></a>好处</h3></li>
<li>提高可维护性:只要修改一个模块或者类。<h3 id="如何做-12"><a href="#如何做-12" class="headerlink" title="如何做"></a>如何做</h3></li>
<li>使用<a href="http://java-design-patterns.com/principles/#Curly-s-Law" target="_blank" rel="noopener">Curly’s Law.</a><h3 id="参考资料-14"><a href="#参考资料-14" class="headerlink" title="参考资料"></a>参考资料</h3></li>
<li><a href="http://en.wikipedia.org/wiki/Single_responsibility_principle" target="_blank" rel="noopener">Single responsibility principle</a><h2 id="隐藏具体的实现细节-Hide-Implementation-Details"><a href="#隐藏具体的实现细节-Hide-Implementation-Details" class="headerlink" title="隐藏具体的实现细节(Hide Implementation Details)"></a>隐藏具体的实现细节(Hide Implementation Details)</h2>一个软件模块通过提供一个接口来隐藏信息(即实现细节)，而不泄漏任何不必要的信息。<h3 id="好处-2"><a href="#好处-2" class="headerlink" title="好处"></a>好处</h3></li>
<li>当实现更改时，客户端所使用的是接口，不需要更改。（多态）<h3 id="如何做-13"><a href="#如何做-13" class="headerlink" title="如何做"></a>如何做</h3></li>
<li>最小化类和成员的作用域。</li>
<li>不要公开公开成员数据。</li>
<li>避免将私有实现细节放入类的接口中。</li>
<li>减少耦合，以隐藏更多的实现细节。<h3 id="参考资料-15"><a href="#参考资料-15" class="headerlink" title="参考资料"></a>参考资料</h3></li>
<li><a href="http://en.wikipedia.org/wiki/Information_hiding" target="_blank" rel="noopener">Information hiding</a><h2 id="Curly’s-Law"><a href="#Curly’s-Law" class="headerlink" title="Curly’s Law"></a>Curly’s Law</h2><h3 id="参考资料-16"><a href="#参考资料-16" class="headerlink" title="参考资料"></a>参考资料</h3></li>
<li><a href="http://blog.codinghorror.com/curlys-law-do-one-thing/" target="_blank" rel="noopener">Curly’s Law: Do One Thing</a></li>
<li><a href="http://fortyplustwo.com/2008/09/06/the-rule-of-one-or-curlys-law/" target="_blank" rel="noopener">The Rule of One or Curly’s Law</a><h2 id="封装变化-Encapsulate-What-Changes"><a href="#封装变化-Encapsulate-What-Changes" class="headerlink" title="封装变化(Encapsulate What Changes)"></a>封装变化(Encapsulate What Changes)</h2>一个好的设计可以识别那些最有可能改变的点，并将它们封装在API背后。当预期的更改发生时，修改将保留在本地。<h3 id="好处-3"><a href="#好处-3" class="headerlink" title="好处"></a>好处</h3></li>
<li>当发生更改时，最小化所需的修改<h3 id="如何做-14"><a href="#如何做-14" class="headerlink" title="如何做"></a>如何做</h3></li>
<li>封装API背后的变化，而提供不变的访问方式。</li>
<li>尽可能的将不同的改变分发到这个模块本身，让其本身负责。<h3 id="参考资料-17"><a href="#参考资料-17" class="headerlink" title="参考资料"></a>参考资料</h3></li>
<li><a href="http://blogs.msdn.com/b/steverowe/archive/2007/12/26/encapsulate-what-varies.aspx" target="_blank" rel="noopener">Encapsulate the Concept that Varies</a></li>
<li><a href="http://blogs.msdn.com/b/steverowe/archive/2007/12/26/encapsulate-what-varies.aspx" target="_blank" rel="noopener">Encapsulate What Varies</a></li>
<li><a href="https://en.wikipedia.org/wiki/Information_hiding" target="_blank" rel="noopener">Information Hiding</a><h2 id="接口分割原则-Interface-Segregation-Principle"><a href="#接口分割原则-Interface-Segregation-Principle" class="headerlink" title="接口分割原则(Interface Segregation Principle)"></a>接口分割原则(Interface Segregation Principle)</h2>将一些方法比较多的接口拆分成多个小的接口。接口应该更依赖于调用它的代码，而不是实现它的代码。<h3 id="原则描述"><a href="#原则描述" class="headerlink" title="原则描述"></a>原则描述</h3><ul>
<li>如果一个类实现了不需要的方法，调用者就需要知道该类的方法实现。例如，如果一个类实现了一个方法，但是只是简单地抛出，那么调用者将需要知道这个方法实际上不应该被调用。HiveStatement实现了Statement接口，然而现在Hive现在并不打算支持其中的一些方法，只是简单的throw Exception了。<h3 id="如何做-15"><a href="#如何做-15" class="headerlink" title="如何做"></a>如何做</h3></li>
</ul>
</li>
<li>避免过于庞大的接口。类不应该实现除了它的职责的方法。<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3></li>
<li><a href="https://en.wikipedia.org/wiki/Interface_segregation_principle" target="_blank" rel="noopener">Interface segregation principle</a><h2 id="命令查询分离-Command-Query-Separation"><a href="#命令查询分离-Command-Query-Separation" class="headerlink" title="命令查询分离(Command Query Separation)"></a>命令查询分离(Command Query Separation)</h2>命令查询分离原则声明，每个方法都应该要么是执行操作的命令，要么是将数据返回给调用者的查询，而不是两者都执行。<br>有了这个原则，程序员就可以更加自信地编写代码了。查询方法可以在任何地方和任何顺序使用，因为它们不会改变状态。有了命令，你必须更加小心。<h3 id="如何做-16"><a href="#如何做-16" class="headerlink" title="如何做"></a>如何做</h3></li>
<li>将每个方法作为一个查询或一个命令来实现。</li>
<li>将命名约定应用于方法名，这意味着该方法是一个查询还是一个命令。<h3 id="参考文献-1"><a href="#参考文献-1" class="headerlink" title="参考文献"></a>参考文献</h3></li>
<li><a href="https://en.wikipedia.org/wiki/Command%E2%80%93query_separation" target="_blank" rel="noopener">Command Query Separation in Wikipedia</a></li>
<li><a href="http://martinfowler.com/bliki/CommandQuerySeparation.html" target="_blank" rel="noopener">Command Query Separation by Martin Fowler</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yangrubing.github.io/2017/08/17/从源码层面看MyBatis的缓存机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Robin Yang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar/obito.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="月光下的影子">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/17/从源码层面看MyBatis的缓存机制/" itemprop="url">从源码层面看MyBatis的缓存机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-17T17:31:18+00:00">
                2017-08-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="MyBatis中的缓存"><a href="#MyBatis中的缓存" class="headerlink" title="MyBatis中的缓存"></a>MyBatis中的缓存</h1><p><code>MyBatis</code> 中主要包括一级缓存和二级缓存。一级缓存指的是 <code>session</code> 级别的缓存，<code>MyBatis</code> 每次创建一个数据库连接，则会产生一个数据库访问的 <code>sqlSession</code> ，在这一次会话中执行了两次相同的数据库查询的话，<code>MyBatis</code>在第二次查询的时候会使用之前缓存的数据，从而提高查询效率；二级缓存指的是应用级别的缓存，开启缓存后，每一个 <code>Mapper</code> 下的查询都会使用缓存数据，二级缓存可以使用自定义实现，也可以使用第三方提供的缓存，如 <code>EHCache</code> 等。</p>
<h2 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h2><h3 id="一级缓存的实现"><a href="#一级缓存的实现" class="headerlink" title="一级缓存的实现"></a>一级缓存的实现</h3><p><code>MyBatis</code> 在进行一次查询时，主要包括如下几个步骤：</p>
<ol>
<li>使用<code>SqlSessionFactoryBuilder</code>从 <code>XML</code> 中读取配置信息，构造一个 <code>SqlSessionFactory</code> 对象。</li>
<li><code>SqlSessionFactory</code> 对象调用 <code>openSession</code> 方法，开启一次数据库会话。</li>
<li><code>session</code> 中持有了一个 <code>Executor</code> 的引用用来执行数据库操作。</li>
</ol>
<p>在上述描述中，查询缓存是否命中是在 <code>executor</code> 执行 <code>sql</code> 时进行的。每个<code>executor</code> 中都包含一个<code>PerpetualCache</code>的缓存，该缓存使用一个简单的<code>HashMap</code> 来实现。在进行查询时首先会查询缓存有没有命中，如果命中，则直接返回结果；否则，从数据库中进行查询并放到缓存中。<br> <code>Executor</code>在执行查询时的代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">   BoundSql boundSql = ms.getBoundSql(parameter);</span><br><span class="line">   <span class="comment">//创建缓存的key</span></span><br><span class="line">   CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql);</span><br><span class="line">   <span class="comment">//调用下面的query方法        </span></span><br><span class="line">   <span class="keyword">return</span> query(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">   <span class="comment">//omitted...</span></span><br><span class="line">   List&lt;E&gt; list;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     queryStack++;</span><br><span class="line">     <span class="comment">//首先从缓存中取数据</span></span><br><span class="line">     list = resultHandler == <span class="keyword">null</span> ? (List&lt;E&gt;) localCache.getObject(key) : <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">       handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//  从数据库中查询，并返回</span></span><br><span class="line">       list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     queryStack--;</span><br><span class="line">   &#125;</span><br><span class="line"> <span class="comment">//omitted...</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>缓存的key的创建使用的是createCacheKey方法，该方法的实现代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CacheKey <span class="title">createCacheKey</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Executor was closed."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  CacheKey cacheKey = <span class="keyword">new</span> CacheKey();</span><br><span class="line">  <span class="comment">//添加MappedStatement的id    </span></span><br><span class="line">  cacheKey.update(ms.getId());</span><br><span class="line">  <span class="comment">//添加rowBound信息，分页时用的</span></span><br><span class="line">  cacheKey.update(Integer.valueOf(rowBounds.getOffset()));</span><br><span class="line">  <span class="comment">////添加rowBound信息，分页时用的</span></span><br><span class="line">  cacheKey.update(Integer.valueOf(rowBounds.getLimit()));</span><br><span class="line">  <span class="comment">//添加sql信息</span></span><br><span class="line">  cacheKey.update(boundSql.getSql());</span><br><span class="line">  List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();</span><br><span class="line">  TypeHandlerRegistry typeHandlerRegistry = ms.getConfiguration().getTypeHandlerRegistry();</span><br><span class="line">  <span class="comment">// mimic DefaultParameterHandler logic</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameterMappings.size(); i++) &#123;</span><br><span class="line">    ParameterMapping parameterMapping = parameterMappings.get(i);</span><br><span class="line">    <span class="keyword">if</span> (parameterMapping.getMode() != ParameterMode.OUT) &#123;</span><br><span class="line">      Object value;</span><br><span class="line">      String propertyName = parameterMapping.getProperty();</span><br><span class="line">      <span class="keyword">if</span> (boundSql.hasAdditionalParameter(propertyName)) &#123;</span><br><span class="line">        value = boundSql.getAdditionalParameter(propertyName);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameterObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">        value = <span class="keyword">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123;</span><br><span class="line">        value = parameterObject;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        MetaObject metaObject = configuration.newMetaObject(parameterObject);</span><br><span class="line">        value = metaObject.getValue(propertyName);</span><br><span class="line">      &#125;</span><br><span class="line">     <span class="comment">//添加查询的参数信息        </span></span><br><span class="line">      cacheKey.update(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">      <span class="comment">//如果Configuration的环境不为空，则把环境的id也加上</span></span><br><span class="line">      <span class="keyword">if</span> (configuration.getEnvironment() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    cacheKey.update(configuration.getEnvironment().getId());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cacheKey;</span><br></pre></td></tr></table></figure></p>
<p>从代码中可以看出，缓存的key由以下几部分组成。</p>
<ul>
<li><code>MappedStatement</code>对象的<code>id</code>。</li>
<li>分页信息<code>RowBound</code>。</li>
<li><code>sql</code> 语句。</li>
<li><code>sql</code>语句中传递的参数</li>
<li>环境名<code>environment</code><br>最后生成的key大约长这样：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">1994665822</span>:<span class="number">3056142341</span>:com.yrb.mybatis.mapper.BookStoreMapper.getBookNames:<span class="number">0</span>:<span class="number">2147483647</span>:select book_name from my_test.book_store where id = ?:<span class="number">4</span>:development</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="一级缓存的使用和生命周期"><a href="#一级缓存的使用和生命周期" class="headerlink" title="一级缓存的使用和生命周期"></a>一级缓存的使用和生命周期</h3><h4 id="一级缓存的使用"><a href="#一级缓存的使用" class="headerlink" title="一级缓存的使用"></a>一级缓存的使用</h4><p>一级缓存默认开启，不过可以进行手动清除；MyBatis认为，对于两次查询，如果以下条件都完全一样，那么就认为它们是完全相同的两次查询：</p>
<ol>
<li>传入的 <code>statementId</code></li>
<li>查询时要求的结果集中的结果范围 （结果的范围通过<code>rowBounds.offset</code>和<code>rowBounds.limit</code>表示）；</li>
<li>这次查询所产生的最终要传递给JDBC <code>Java.sql.Preparedstatement</code>的Sql语句字符串（<code>boundSql.getSql()</code>）</li>
<li>传递给 <code>java.sql.Statement</code> 要设置的参数值<br><strong>3、4两条<code>MyBatis</code>最本质的要求就是 ： 调用<code>JDBC</code>的时候，传入的SQL语句要完全相同，传递给<code>JDBC</code>的参数值也要完全相同。</strong><br>根据一级缓存的特性，在使用的过程中，我认为应该注意：</li>
<li>对于数据变化频率很大，并且需要高时效准确性的数据要求，我们使用<code>SqlSession</code> 查询的时候，要控制好<code>SqlSession</code> 的生存时间，<code>SqlSession</code> 的生存时间越长，它其中缓存的数据有可能就越旧，从而造成和真实数据库的误差；同时对于这种情况，用户也可以手动地适时清空 <code>SqlSession</code> 中的缓存；</li>
<li>对于只执行、并且频繁执行大范围的 <code>select</code>操作的 <code>SqlSession</code> 对象，<code>SqlSession</code> 对象的生存时间不应过长。</li>
</ol>
<h4 id="一级缓存的生命周期"><a href="#一级缓存的生命周期" class="headerlink" title="一级缓存的生命周期"></a>一级缓存的生命周期</h4><p>一级缓存在 <code>session</code> 中创建，因此它的生命周期和<code>session</code> 的生命周期一致。随 <code>session</code>而生，随 <code>session</code>而死。<strong>同时注意，在执行更新操作时，也会清空该<code>session</code>的一级缓存。</strong></p>
<h2 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h2><p>二级缓存可以看下<a href="http://blog.csdn.net/luanlouis/article/details/41408341" target="_blank" rel="noopener">《深入理解mybatis原理》 MyBatis的二级缓存的设计原理</a>。主要讲解了二级缓存的配置使用以及原理。需要注意的：</p>
<ul>
<li>缓存的使用顺序<strong>二级缓存 -&gt; 一级缓存-&gt; 数据库</strong>。</li>
<li>缓存策略有 <strong>FIFO</strong>、<strong>LRU</strong>、<strong>Scheduled</strong>（指定时间清空）。</li>
<li>二级缓存的作用域：以<strong>Mapper</strong>区分，通常一个<strong>Mapper</strong>一个<strong>Cache</strong>，也可以多个Mapper公用一个<strong>Cache</strong>对象。</li>
<li>二级缓存的实现有三种选择：<ul>
<li><strong>MyBatis</strong>自身提供的缓存实现；</li>
<li>用户自定义的<strong>Cache</strong>接口实现（实现<strong>Cache</strong>接口，并在<code>&lt;cache /&gt;</code>中指明）</li>
<li>跟第三方内存缓存库的集成(如<strong>Ehcache</strong>等)；</li>
</ul>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>MyBatis可以采用<strong>一级缓存</strong>和<strong>二级缓存</strong>；一级缓存不需要配置，默认开启，但是在一些实时性要求较高的应用可能需要手动清空缓存。二级缓存指的是应用级别的缓存，在每一个Mapper都对应一个Cache对象，也可以多个Mapper共有一个；在实际项目中，我们使用的是用Redis来实现自己的缓存。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://blog.csdn.net/luanlouis/article/details/41280959" target="_blank" rel="noopener">《深入理解mybatis原理》 MyBatis的一级缓存实现详解 及使用注意事项</a></li>
<li><a href="http://www.mybatis.org/mybatis-3/zh/java-api.html" target="_blank" rel="noopener">MyBatis Java API</a></li>
<li><a href="http://blog.csdn.net/luanlouis/article/details/41408341" target="_blank" rel="noopener">《深入理解mybatis原理》 MyBatis的二级缓存的设计原理</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yangrubing.github.io/2017/08/16/策略模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Robin Yang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar/obito.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="月光下的影子">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/16/策略模式/" itemprop="url">策略模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-16T17:46:20+00:00">
                2017-08-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><blockquote>
<p>策略模式是一种软件设计模式，它可以在运行时动态的选择算法的行为。</p>
</blockquote>
<p>例如：现在我们要完成一件事情，可以有多重策略，如策略A、策略B、策略C等。我们的需求是想要在不同的情况下选择使用不同的策略。在Java中，我们可以使用多态来实现这个功能。策略模式还体现了<strong>面向接口而不是面向实现</strong>来编程的原则。</p>
<h2 id="示例说明"><a href="#示例说明" class="headerlink" title="示例说明"></a>示例说明</h2><p>如下图所示，我们需要完成一个屠龙的任务。屠龙者（DragonSlayer）可以有三种策略来完成这个任务，分别为<code>ProjectileStrategy</code>、<code>MeleeStrategy</code>、<code>SpellStrategy</code>。<code>DragonSlayer</code>可以在运行时动态的选择这三种策略来完成屠龙的任务。<br>类之间的关系图如下所示：</p>
<p><img src="/images/2017-08-22-10-50-45.jpg" alt="策略模式的类的关系图"><br>可以看出，这三种策略都实现了<code>DragonSlayingStrategy</code>这个接口，这个接口定义了一个<code>execute</code>的方法。</p>
<h2 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 策略的接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DragonSlayingStrategy</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MeleeStrategy:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MeleeStrategy</span> <span class="keyword">implements</span> <span class="title">DragonSlayingStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(MeleeStrategy.class);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//用你的神剑，你切断了龙的头！</span></span><br><span class="line">    LOGGER.info(<span class="string">"With your Excalibur you sever the dragon's head!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ProjectileStrategy:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Projectile strategy.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProjectileStrategy</span> <span class="keyword">implements</span> <span class="title">DragonSlayingStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(ProjectileStrategy.class);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//你用神奇的弩向龙射击，它倒在地上！</span></span><br><span class="line">    LOGGER.info(<span class="string">"You shoot the dragon with the magical crossbow and it falls dead on the ground!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>SpellStrategy:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Spell strategy.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpellStrategy</span> <span class="keyword">implements</span> <span class="title">DragonSlayingStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(SpellStrategy.class);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//你施放了瓦解的魔咒，龙在一堆尘埃中蒸发了！</span></span><br><span class="line">    LOGGER.info(<span class="string">"You cast the spell of disintegration and the dragon vaporizes in a pile of dust!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面来看看如何使用这三个策略，<code>DragonSlayer</code> 这个类通过<strong>组合</strong>的方式在自己的内部持有了一个策略。注意的是，该策略是一个接口，而没有具体指定是哪一个策略。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DragonSlayer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//持有了一个策略，并通过构造函数来初始化</span></span><br><span class="line">  <span class="keyword">private</span> DragonSlayingStrategy strategy;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DragonSlayer</span><span class="params">(DragonSlayingStrategy strategy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//改变策略</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeStrategy</span><span class="params">(DragonSlayingStrategy strategy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//战斗吧， 哈哈！</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goToBattle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    strategy.execute();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// GoF Strategy pattern</span></span><br><span class="line">    LOGGER.info(<span class="string">"Green dragon spotted ahead!"</span>);</span><br><span class="line">    DragonSlayer dragonSlayer = <span class="keyword">new</span> DragonSlayer(<span class="keyword">new</span> MeleeStrategy());</span><br><span class="line">    dragonSlayer.goToBattle();</span><br><span class="line">    LOGGER.info(<span class="string">"Red dragon emerges."</span>);</span><br><span class="line">    dragonSlayer.changeStrategy(<span class="keyword">new</span> ProjectileStrategy());</span><br><span class="line">    dragonSlayer.goToBattle();</span><br><span class="line">    LOGGER.info(<span class="string">"Black dragon lands before you."</span>);</span><br><span class="line">    dragonSlayer.changeStrategy(<span class="keyword">new</span> SpellStrategy());</span><br><span class="line">    dragonSlayer.goToBattle();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意，在新的java8中，使用lambda表达式可以更方便的实现策略模式</span></span><br><span class="line">    <span class="comment">//减少了代码量</span></span><br><span class="line">    LOGGER.info(<span class="string">"Green dragon spotted ahead!"</span>);</span><br><span class="line">    dragonSlayer = <span class="keyword">new</span> DragonSlayer(</span><br><span class="line">        () -&gt; LOGGER.info(<span class="string">"With your Excalibur you severe the dragon's head!"</span>));</span><br><span class="line">    dragonSlayer.goToBattle();</span><br><span class="line">    LOGGER.info(<span class="string">"Red dragon emerges."</span>);</span><br><span class="line">    dragonSlayer.changeStrategy(() -&gt; LOGGER.info(</span><br><span class="line">        <span class="string">"You shoot the dragon with the magical crossbow and it falls dead on the ground!"</span>));</span><br><span class="line">    dragonSlayer.goToBattle();</span><br><span class="line">    LOGGER.info(<span class="string">"Black dragon lands before you."</span>);</span><br><span class="line">    dragonSlayer.changeStrategy(() -&gt; LOGGER.info(</span><br><span class="line">        <span class="string">"You cast the spell of disintegration and the dragon vaporizes in a pile of dust!"</span>));</span><br><span class="line">    dragonSlayer.goToBattle();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span>:<span class="number">02</span>:<span class="number">32.567</span> [main] INFO com.iluwatar.strategy.App - Green dragon spotted ahead!</span><br><span class="line"><span class="number">11</span>:<span class="number">02</span>:<span class="number">32.616</span> [main] INFO com.iluwatar.strategy.App - With your Excalibur you severe the dragon<span class="string">'s head!</span></span><br><span class="line"><span class="string">11:02:32.616 [main] INFO com.iluwatar.strategy.App - Red dragon emerges.</span></span><br><span class="line"><span class="string">11:02:32.616 [main] INFO com.iluwatar.strategy.App - You shoot the dragon with the magical crossbow and it falls dead on the ground!</span></span><br><span class="line"><span class="string">11:02:32.616 [main] INFO com.iluwatar.strategy.App - Black dragon lands before you.</span></span><br><span class="line"><span class="string">11:02:32.616 [main] INFO com.iluwatar.strategy.App - You cast the spell of disintegration and the dragon vaporizes in a pile of dust!</span></span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar/obito.jpg" alt="Robin Yang">
            
              <p class="site-author-name" itemprop="name">Robin Yang</p>
              <p class="site-description motion-element" itemprop="description">Only the stronger survive in the world.</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Robin Yang</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
